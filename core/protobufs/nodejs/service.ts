// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.21.12
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "";

/** ResultStatus indicates the outcome of algorithm execution */
export enum ResultStatus {
  /**
   * RESULT_STATUS_HANDLED_FAILED - Algorithm failed but the error was handled gracefully
   * The system may retry or skip depending on configuration
   */
  RESULT_STATUS_HANDLED_FAILED = 0,
  /**
   * RESULT_STATUS_UNHANDLED_FAILED - Algorithm failed with an unexpected error
   * Requires investigation and may halt dependent processing
   */
  RESULT_STATUS_UNHANDLED_FAILED = 1,
  /**
   * RESULT_STATUS_SUCEEDED - Algorithm completed successfully
   * Results are valid and can be used by dependent algorithms
   */
  RESULT_STATUS_SUCEEDED = 2,
  UNRECOGNIZED = -1,
}

export function resultStatusFromJSON(object: any): ResultStatus {
  switch (object) {
    case 0:
    case "RESULT_STATUS_HANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_HANDLED_FAILED;
    case 1:
    case "RESULT_STATUS_UNHANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_UNHANDLED_FAILED;
    case 2:
    case "RESULT_STATUS_SUCEEDED":
      return ResultStatus.RESULT_STATUS_SUCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultStatus.UNRECOGNIZED;
  }
}

export function resultStatusToJSON(object: ResultStatus): string {
  switch (object) {
    case ResultStatus.RESULT_STATUS_HANDLED_FAILED:
      return "RESULT_STATUS_HANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_UNHANDLED_FAILED:
      return "RESULT_STATUS_UNHANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_SUCEEDED:
      return "RESULT_STATUS_SUCEEDED";
    case ResultStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Window represents a time-bounded processing context that triggers algorithm execution. Windows are the primary input that start DAG processing flows. */
export interface Window {
  /**
   * Time that the window starts - nanoseconds since epoch
   * Required: Must be > 0 and < to
   */
  timeFrom: number;
  /**
   * Time that the window ends - nanoseconds since epoch
   * Required: Must be > from
   */
  timeTo: number;
  /**
   * The canonical name of the window that uniquely identifies it
   * This allows tracking of window state and results across the system
   * Required: Must be unique within the system, and refer directly to
   * window type
   */
  windowTypeName: string;
  /** The version of the window type, as defined by WindoType */
  windowTypeVersion: string;
  /** A unique identifier that defines where the window came from */
  origin: string;
}

/**
 * WindowType defines a category of window that can trigger algorithms.
 * Algorithms subscribe to window types to indicate when they should be executed.
 */
export interface WindowType {
  /**
   * Name of the window type - must be globally unique
   * Examples: "daily", "hourly", "market_close", "event_triggered"
   */
  name: string;
  /**
   * Version of the algorithm. Follows basic semver and allows window
   * types to be changed over time, with traceability
   */
  version: string;
}

export interface WindowEmitStatus {
  status: WindowEmitStatus_StatusEnum;
}

/** A status enum that captures scenarios regarding a window being emmited */
export enum WindowEmitStatus_StatusEnum {
  /** NO_TRIGGERED_ALGORITHMS - When no algorithms could be found that are triggered by this window */
  NO_TRIGGERED_ALGORITHMS = 0,
  /** PROCESSING_TRIGGERED - When processing has successfully been triggered */
  PROCESSING_TRIGGERED = 1,
  /** TRIGGERING_FAILED - When triggering has failed */
  TRIGGERING_FAILED = 2,
  UNRECOGNIZED = -1,
}

export function windowEmitStatus_StatusEnumFromJSON(object: any): WindowEmitStatus_StatusEnum {
  switch (object) {
    case 0:
    case "NO_TRIGGERED_ALGORITHMS":
      return WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS;
    case 1:
    case "PROCESSING_TRIGGERED":
      return WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED;
    case 2:
    case "TRIGGERING_FAILED":
      return WindowEmitStatus_StatusEnum.TRIGGERING_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowEmitStatus_StatusEnum.UNRECOGNIZED;
  }
}

export function windowEmitStatus_StatusEnumToJSON(object: WindowEmitStatus_StatusEnum): string {
  switch (object) {
    case WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS:
      return "NO_TRIGGERED_ALGORITHMS";
    case WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED:
      return "PROCESSING_TRIGGERED";
    case WindowEmitStatus_StatusEnum.TRIGGERING_FAILED:
      return "TRIGGERING_FAILED";
    case WindowEmitStatus_StatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AlgorithmDependency defines a requirement that one algorithm has on another's results.
 * These dependencies form the edges in the processing DAG.
 */
export interface AlgorithmDependency {
  /**
   * Name of the required algorithm
   * Must reference an existing algorithm name in the system
   */
  name: string;
  /**
   * Version of the required algorithm
   * Must follow semantic versioning (e.g., "1.0.0")
   */
  version: string;
  /** Name of the processor that the algorithm is associated with */
  processorName: string;
  /** Runtime of the processor that the algorithm is associated with */
  processorRuntime: string;
}

/**
 * Algorithm defines a processing unit that can be executed by processors.
 * Algorithms form the nodes in the processing DAG and are triggered by specific window types.
 */
export interface Algorithm {
  /**
   * Name of the algorithm - must be globally unique
   * This identifies the algorithm across the system
   */
  name: string;
  /**
   * Version of the algorithm - must follow semantic versioning
   * Allows for algorithm evolution while maintaining compatibility
   */
  version: string;
  /**
   * Type of window that triggers this algorithm
   * References a WindowType that will cause this algorithm to execute
   */
  windowType:
    | WindowType
    | undefined;
  /**
   * Other algorithms that this algorithm depends on
   * The algorithm won't execute until all dependencies have completed
   * Dependencies must not form cycles - this is statically checked on processor registration
   */
  dependencies: AlgorithmDependency[];
}

/** Container for array of float values */
export interface FloatArray {
  values: number[];
}

/** Result of an algorithm execution */
export interface Result {
  /** Status of the result execution */
  status: ResultStatus;
  /** for single number results */
  singleValue?:
    | number
    | undefined;
  /** For numeric array results */
  floatValues?:
    | FloatArray
    | undefined;
  /**
   * For structured data results (JSON-like)
   * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
   */
  structValue?:
    | { [key: string]: any }
    | undefined;
  /** Timestamp when the result was produced */
  timestamp: number;
}

/**
 * ProcessorRegistration is sent by processors when they start up to announce their capabilities
 * to the orchestrator. This establishes a long-lived connection for receiving tasks.
 */
export interface ProcessorRegistration {
  /** Unique name of the runtime */
  name: string;
  /**
   * Language/runtime of the processor
   * Examples: "python3.9", "go1.19", "Rust4.1"
   */
  runtime: string;
  /**
   * The connection string of the processor
   * e.g. grpc://localhost:5433
   */
  connectionStr: string;
  /**
   * Algorithms this processor can execute
   * The processor must implement all listed algorithms
   */
  supportedAlgorithms: Algorithm[];
}

/**
 * ProcessingTask represents a single algorithm execution request sent to a processor.
 * Tasks are streamed to processors as their dependencies are satisfied.
 */
export interface ProcessingTask {
  /**
   * Unique ID for this specific task execution
   * Used to correlate results and track execution state
   */
  taskId: string;
  /**
   * Algorithm to execute
   * Must be one of the algorithms the processor registered support for
   */
  algorithm:
    | Algorithm
    | undefined;
  /**
   * Window that triggered this task
   * Provides the time context for the algorithm execution
   */
  window:
    | Window
    | undefined;
  /**
   * Results from dependent algorithms
   * Contains all results that this algorithm declared dependencies on
   * All dependencies will be present when task is sent
   */
  dependencyResults: Result[];
}

/**
 * ExecutionRequest provides a complete view of a processing DAG's execution
 * status for a specific window. Used for monitoring and debugging.
 */
export interface ExecutionRequest {
  /** The exec_id */
  execId: string;
  /** The window that triggered the algorithm */
  window:
    | Window
    | undefined;
  /** Results from dependant algorithms */
  algorithmResults: AlgorithmResult[];
  /** The algorithms to execute */
  algorithms: Algorithm[];
}

export interface ExecutionResult {
  /** Exec ID */
  execId: string;
  /** The algorithn result */
  algorithmResult: AlgorithmResult | undefined;
}

/** AlgorithmWindowResult Packaged algorithm and result to a window */
export interface AlgorithmResult {
  algorithm: Algorithm | undefined;
  result: Result | undefined;
}

export interface Status {
  received: boolean;
  message: string;
}

/** HealthCheckRequest is sent to processors to verify they are functioning */
export interface HealthCheckRequest {
  /**
   * Timestamp of the request in unix epoch milliseconds
   * Used to measure response latency
   */
  timestamp: number;
}

/** HealthCheckResponse indicates the health status of a processor */
export interface HealthCheckResponse {
  /** Current health status */
  status: HealthCheckResponse_Status;
  /** Optional message providing more detail about the health status */
  message: string;
  /** System metrics about the processor */
  metrics: ProcessorMetrics | undefined;
}

/** Overall health status of the processor */
export enum HealthCheckResponse_Status {
  /** STATUS_UNKNOWN - Unknown status - should never be used */
  STATUS_UNKNOWN = 0,
  /** STATUS_SERVING - Processor is healthy and ready to accept tasks */
  STATUS_SERVING = 1,
  /** STATUS_TRANSITIONING - Processor is starting up or shutting down */
  STATUS_TRANSITIONING = 2,
  /** STATUS_NOT_SERVING - Processor is not healthy and cannot accept tasks */
  STATUS_NOT_SERVING = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_StatusFromJSON(object: any): HealthCheckResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return HealthCheckResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_SERVING":
      return HealthCheckResponse_Status.STATUS_SERVING;
    case 2:
    case "STATUS_TRANSITIONING":
      return HealthCheckResponse_Status.STATUS_TRANSITIONING;
    case 3:
    case "STATUS_NOT_SERVING":
      return HealthCheckResponse_Status.STATUS_NOT_SERVING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_Status.UNRECOGNIZED;
  }
}

export function healthCheckResponse_StatusToJSON(object: HealthCheckResponse_Status): string {
  switch (object) {
    case HealthCheckResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case HealthCheckResponse_Status.STATUS_SERVING:
      return "STATUS_SERVING";
    case HealthCheckResponse_Status.STATUS_TRANSITIONING:
      return "STATUS_TRANSITIONING";
    case HealthCheckResponse_Status.STATUS_NOT_SERVING:
      return "STATUS_NOT_SERVING";
    case HealthCheckResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ProcessorMetrics provides runtime information about a processor */
export interface ProcessorMetrics {
  /** Number of algorithms currently being executed */
  activeTasks: number;
  /** Memory usage in bytes */
  memoryBytes: number;
  /** CPU usage percentage (0-100) */
  cpuPercent: number;
  /** Time since processor started in seconds */
  uptimeSeconds: number;
}

/** ---------------------------- Data Messages ---------------------------- */
export interface WindowTypeRead {
}

export interface WindowTypes {
  windows: WindowType[];
}

function createBaseWindow(): Window {
  return { timeFrom: 0, timeTo: 0, windowTypeName: "", windowTypeVersion: "", origin: "" };
}

export const Window: MessageFns<Window> = {
  encode(message: Window, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== 0) {
      writer.uint32(8).uint64(message.timeFrom);
    }
    if (message.timeTo !== 0) {
      writer.uint32(16).uint64(message.timeTo);
    }
    if (message.windowTypeName !== "") {
      writer.uint32(26).string(message.windowTypeName);
    }
    if (message.windowTypeVersion !== "") {
      writer.uint32(34).string(message.windowTypeVersion);
    }
    if (message.origin !== "") {
      writer.uint32(42).string(message.origin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Window {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeFrom = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timeTo = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowTypeVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Window {
    return {
      timeFrom: isSet(object.timeFrom) ? globalThis.Number(object.timeFrom) : 0,
      timeTo: isSet(object.timeTo) ? globalThis.Number(object.timeTo) : 0,
      windowTypeName: isSet(object.windowTypeName) ? globalThis.String(object.windowTypeName) : "",
      windowTypeVersion: isSet(object.windowTypeVersion) ? globalThis.String(object.windowTypeVersion) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
    };
  },

  toJSON(message: Window): unknown {
    const obj: any = {};
    if (message.timeFrom !== 0) {
      obj.timeFrom = Math.round(message.timeFrom);
    }
    if (message.timeTo !== 0) {
      obj.timeTo = Math.round(message.timeTo);
    }
    if (message.windowTypeName !== "") {
      obj.windowTypeName = message.windowTypeName;
    }
    if (message.windowTypeVersion !== "") {
      obj.windowTypeVersion = message.windowTypeVersion;
    }
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Window>, I>>(base?: I): Window {
    return Window.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Window>, I>>(object: I): Window {
    const message = createBaseWindow();
    message.timeFrom = object.timeFrom ?? 0;
    message.timeTo = object.timeTo ?? 0;
    message.windowTypeName = object.windowTypeName ?? "";
    message.windowTypeVersion = object.windowTypeVersion ?? "";
    message.origin = object.origin ?? "";
    return message;
  },
};

function createBaseWindowType(): WindowType {
  return { name: "", version: "" };
}

export const WindowType: MessageFns<WindowType> = {
  encode(message: WindowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: WindowType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowType>, I>>(base?: I): WindowType {
    return WindowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowType>, I>>(object: I): WindowType {
    const message = createBaseWindowType();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseWindowEmitStatus(): WindowEmitStatus {
  return { status: 0 };
}

export const WindowEmitStatus: MessageFns<WindowEmitStatus> = {
  encode(message: WindowEmitStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowEmitStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowEmitStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowEmitStatus {
    return { status: isSet(object.status) ? windowEmitStatus_StatusEnumFromJSON(object.status) : 0 };
  },

  toJSON(message: WindowEmitStatus): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = windowEmitStatus_StatusEnumToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(base?: I): WindowEmitStatus {
    return WindowEmitStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(object: I): WindowEmitStatus {
    const message = createBaseWindowEmitStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseAlgorithmDependency(): AlgorithmDependency {
  return { name: "", version: "", processorName: "", processorRuntime: "" };
}

export const AlgorithmDependency: MessageFns<AlgorithmDependency> = {
  encode(message: AlgorithmDependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.processorName !== "") {
      writer.uint32(26).string(message.processorName);
    }
    if (message.processorRuntime !== "") {
      writer.uint32(34).string(message.processorRuntime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmDependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processorRuntime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmDependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      processorName: isSet(object.processorName) ? globalThis.String(object.processorName) : "",
      processorRuntime: isSet(object.processorRuntime) ? globalThis.String(object.processorRuntime) : "",
    };
  },

  toJSON(message: AlgorithmDependency): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.processorName !== "") {
      obj.processorName = message.processorName;
    }
    if (message.processorRuntime !== "") {
      obj.processorRuntime = message.processorRuntime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(base?: I): AlgorithmDependency {
    return AlgorithmDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(object: I): AlgorithmDependency {
    const message = createBaseAlgorithmDependency();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.processorName = object.processorName ?? "";
    message.processorRuntime = object.processorRuntime ?? "";
    return message;
  },
};

function createBaseAlgorithm(): Algorithm {
  return { name: "", version: "", windowType: undefined, dependencies: [] };
}

export const Algorithm: MessageFns<Algorithm> = {
  encode(message: Algorithm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.windowType !== undefined) {
      WindowType.encode(message.windowType, writer.uint32(26).fork()).join();
    }
    for (const v of message.dependencies) {
      AlgorithmDependency.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowType = WindowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dependencies.push(AlgorithmDependency.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithm {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      windowType: isSet(object.windowType) ? WindowType.fromJSON(object.windowType) : undefined,
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => AlgorithmDependency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Algorithm): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.windowType !== undefined) {
      obj.windowType = WindowType.toJSON(message.windowType);
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => AlgorithmDependency.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithm>, I>>(base?: I): Algorithm {
    return Algorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithm>, I>>(object: I): Algorithm {
    const message = createBaseAlgorithm();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.windowType = (object.windowType !== undefined && object.windowType !== null)
      ? WindowType.fromPartial(object.windowType)
      : undefined;
    message.dependencies = object.dependencies?.map((e) => AlgorithmDependency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatArray(): FloatArray {
  return { values: [] };
}

export const FloatArray: MessageFns<FloatArray> = {
  encode(message: FloatArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatArray>, I>>(base?: I): FloatArray {
    return FloatArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatArray>, I>>(object: I): FloatArray {
    const message = createBaseFloatArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseResult(): Result {
  return { status: 0, singleValue: undefined, floatValues: undefined, structValue: undefined, timestamp: 0 };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.singleValue !== undefined) {
      writer.uint32(21).float(message.singleValue);
    }
    if (message.floatValues !== undefined) {
      FloatArray.encode(message.floatValues, writer.uint32(26).fork()).join();
    }
    if (message.structValue !== undefined) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(34).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.singleValue = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.floatValues = FloatArray.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      status: isSet(object.status) ? resultStatusFromJSON(object.status) : 0,
      singleValue: isSet(object.singleValue) ? globalThis.Number(object.singleValue) : undefined,
      floatValues: isSet(object.floatValues) ? FloatArray.fromJSON(object.floatValues) : undefined,
      structValue: isObject(object.structValue) ? object.structValue : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = resultStatusToJSON(message.status);
    }
    if (message.singleValue !== undefined) {
      obj.singleValue = message.singleValue;
    }
    if (message.floatValues !== undefined) {
      obj.floatValues = FloatArray.toJSON(message.floatValues);
    }
    if (message.structValue !== undefined) {
      obj.structValue = message.structValue;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.status = object.status ?? 0;
    message.singleValue = object.singleValue ?? undefined;
    message.floatValues = (object.floatValues !== undefined && object.floatValues !== null)
      ? FloatArray.fromPartial(object.floatValues)
      : undefined;
    message.structValue = object.structValue ?? undefined;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseProcessorRegistration(): ProcessorRegistration {
  return { name: "", runtime: "", connectionStr: "", supportedAlgorithms: [] };
}

export const ProcessorRegistration: MessageFns<ProcessorRegistration> = {
  encode(message: ProcessorRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    if (message.connectionStr !== "") {
      writer.uint32(26).string(message.connectionStr);
    }
    for (const v of message.supportedAlgorithms) {
      Algorithm.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectionStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.supportedAlgorithms.push(Algorithm.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorRegistration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      connectionStr: isSet(object.connectionStr) ? globalThis.String(object.connectionStr) : "",
      supportedAlgorithms: globalThis.Array.isArray(object?.supportedAlgorithms)
        ? object.supportedAlgorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorRegistration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.connectionStr !== "") {
      obj.connectionStr = message.connectionStr;
    }
    if (message.supportedAlgorithms?.length) {
      obj.supportedAlgorithms = message.supportedAlgorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(base?: I): ProcessorRegistration {
    return ProcessorRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(object: I): ProcessorRegistration {
    const message = createBaseProcessorRegistration();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    message.connectionStr = object.connectionStr ?? "";
    message.supportedAlgorithms = object.supportedAlgorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessingTask(): ProcessingTask {
  return { taskId: "", algorithm: undefined, window: undefined, dependencyResults: [] };
}

export const ProcessingTask: MessageFns<ProcessingTask> = {
  encode(message: ProcessingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(26).fork()).join();
    }
    for (const v of message.dependencyResults) {
      Result.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dependencyResults.push(Result.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      dependencyResults: globalThis.Array.isArray(object?.dependencyResults)
        ? object.dependencyResults.map((e: any) => Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessingTask): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.dependencyResults?.length) {
      obj.dependencyResults = message.dependencyResults.map((e) => Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingTask>, I>>(base?: I): ProcessingTask {
    return ProcessingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingTask>, I>>(object: I): ProcessingTask {
    const message = createBaseProcessingTask();
    message.taskId = object.taskId ?? "";
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.dependencyResults = object.dependencyResults?.map((e) => Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionRequest(): ExecutionRequest {
  return { execId: "", window: undefined, algorithmResults: [], algorithms: [] };
}

export const ExecutionRequest: MessageFns<ExecutionRequest> = {
  encode(message: ExecutionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(18).fork()).join();
    }
    for (const v of message.algorithmResults) {
      AlgorithmResult.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.algorithms) {
      Algorithm.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithmResults.push(AlgorithmResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.algorithms.push(Algorithm.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionRequest {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      algorithmResults: globalThis.Array.isArray(object?.algorithmResults)
        ? object.algorithmResults.map((e: any) => AlgorithmResult.fromJSON(e))
        : [],
      algorithms: globalThis.Array.isArray(object?.algorithms)
        ? object.algorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecutionRequest): unknown {
    const obj: any = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.algorithmResults?.length) {
      obj.algorithmResults = message.algorithmResults.map((e) => AlgorithmResult.toJSON(e));
    }
    if (message.algorithms?.length) {
      obj.algorithms = message.algorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionRequest>, I>>(base?: I): ExecutionRequest {
    return ExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionRequest>, I>>(object: I): ExecutionRequest {
    const message = createBaseExecutionRequest();
    message.execId = object.execId ?? "";
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.algorithmResults = object.algorithmResults?.map((e) => AlgorithmResult.fromPartial(e)) || [];
    message.algorithms = object.algorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { execId: "", algorithmResult: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.algorithmResult !== undefined) {
      AlgorithmResult.encode(message.algorithmResult, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithmResult = AlgorithmResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      algorithmResult: isSet(object.algorithmResult) ? AlgorithmResult.fromJSON(object.algorithmResult) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.algorithmResult !== undefined) {
      obj.algorithmResult = AlgorithmResult.toJSON(message.algorithmResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.execId = object.execId ?? "";
    message.algorithmResult = (object.algorithmResult !== undefined && object.algorithmResult !== null)
      ? AlgorithmResult.fromPartial(object.algorithmResult)
      : undefined;
    return message;
  },
};

function createBaseAlgorithmResult(): AlgorithmResult {
  return { algorithm: undefined, result: undefined };
}

export const AlgorithmResult: MessageFns<AlgorithmResult> = {
  encode(message: AlgorithmResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmResult {
    return {
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: AlgorithmResult): unknown {
    const obj: any = {};
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmResult>, I>>(base?: I): AlgorithmResult {
    return AlgorithmResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmResult>, I>>(object: I): AlgorithmResult {
    const message = createBaseAlgorithmResult();
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseStatus(): Status {
  return { received: false, message: "" };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.received !== false) {
      writer.uint32(8).bool(message.received);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.received = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      received: isSet(object.received) ? globalThis.Boolean(object.received) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.received !== false) {
      obj.received = message.received;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.received = object.received ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { timestamp: 0 };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0 };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, message: "", metrics: undefined };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metrics !== undefined) {
      ProcessorMetrics.encode(message.metrics, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics = ProcessorMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthCheckResponse_StatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: isSet(object.metrics) ? ProcessorMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthCheckResponse_StatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics !== undefined) {
      obj.metrics = ProcessorMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ProcessorMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseProcessorMetrics(): ProcessorMetrics {
  return { activeTasks: 0, memoryBytes: 0, cpuPercent: 0, uptimeSeconds: 0 };
}

export const ProcessorMetrics: MessageFns<ProcessorMetrics> = {
  encode(message: ProcessorMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeTasks !== 0) {
      writer.uint32(8).int32(message.activeTasks);
    }
    if (message.memoryBytes !== 0) {
      writer.uint32(16).int64(message.memoryBytes);
    }
    if (message.cpuPercent !== 0) {
      writer.uint32(29).float(message.cpuPercent);
    }
    if (message.uptimeSeconds !== 0) {
      writer.uint32(32).int64(message.uptimeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeTasks = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryBytes = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.cpuPercent = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uptimeSeconds = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorMetrics {
    return {
      activeTasks: isSet(object.activeTasks) ? globalThis.Number(object.activeTasks) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.Number(object.memoryBytes) : 0,
      cpuPercent: isSet(object.cpuPercent) ? globalThis.Number(object.cpuPercent) : 0,
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.Number(object.uptimeSeconds) : 0,
    };
  },

  toJSON(message: ProcessorMetrics): unknown {
    const obj: any = {};
    if (message.activeTasks !== 0) {
      obj.activeTasks = Math.round(message.activeTasks);
    }
    if (message.memoryBytes !== 0) {
      obj.memoryBytes = Math.round(message.memoryBytes);
    }
    if (message.cpuPercent !== 0) {
      obj.cpuPercent = message.cpuPercent;
    }
    if (message.uptimeSeconds !== 0) {
      obj.uptimeSeconds = Math.round(message.uptimeSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(base?: I): ProcessorMetrics {
    return ProcessorMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(object: I): ProcessorMetrics {
    const message = createBaseProcessorMetrics();
    message.activeTasks = object.activeTasks ?? 0;
    message.memoryBytes = object.memoryBytes ?? 0;
    message.cpuPercent = object.cpuPercent ?? 0;
    message.uptimeSeconds = object.uptimeSeconds ?? 0;
    return message;
  },
};

function createBaseWindowTypeRead(): WindowTypeRead {
  return {};
}

export const WindowTypeRead: MessageFns<WindowTypeRead> = {
  encode(_: WindowTypeRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypeRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypeRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WindowTypeRead {
    return {};
  },

  toJSON(_: WindowTypeRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypeRead>, I>>(base?: I): WindowTypeRead {
    return WindowTypeRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypeRead>, I>>(_: I): WindowTypeRead {
    const message = createBaseWindowTypeRead();
    return message;
  },
};

function createBaseWindowTypes(): WindowTypes {
  return { windows: [] };
}

export const WindowTypes: MessageFns<WindowTypes> = {
  encode(message: WindowTypes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.windows) {
      WindowType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.windows.push(WindowType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowTypes {
    return {
      windows: globalThis.Array.isArray(object?.windows) ? object.windows.map((e: any) => WindowType.fromJSON(e)) : [],
    };
  },

  toJSON(message: WindowTypes): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => WindowType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypes>, I>>(base?: I): WindowTypes {
    return WindowTypes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypes>, I>>(object: I): WindowTypes {
    const message = createBaseWindowTypes();
    message.windows = object.windows?.map((e) => WindowType.fromPartial(e)) || [];
    return message;
  },
};

/**
 * OrcaCore is the central orchestration service that:
 * - Manages the lifecycle of processing windows
 * - Coordinates algorithm execution across distributed processors
 * - Tracks DAG dependencies and execution state
 * - Routes results between dependent algorithms
 */
export interface OrcaCore {
  /** Register a processor node and its supported algorithms */
  RegisterProcessor(request: ProcessorRegistration): Promise<Status>;
  /** Submit a window for processing */
  EmitWindow(request: Window): Promise<WindowEmitStatus>;
  /** Data operations */
  ReadWindowTypes(request: WindowTypeRead): Promise<WindowTypes>;
}

export const OrcaCoreServiceName = "OrcaCore";
export class OrcaCoreClientImpl implements OrcaCore {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || OrcaCoreServiceName;
    this.rpc = rpc;
    this.RegisterProcessor = this.RegisterProcessor.bind(this);
    this.EmitWindow = this.EmitWindow.bind(this);
    this.ReadWindowTypes = this.ReadWindowTypes.bind(this);
  }
  RegisterProcessor(request: ProcessorRegistration): Promise<Status> {
    const data = ProcessorRegistration.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterProcessor", data);
    return promise.then((data) => Status.decode(new BinaryReader(data)));
  }

  EmitWindow(request: Window): Promise<WindowEmitStatus> {
    const data = Window.encode(request).finish();
    const promise = this.rpc.request(this.service, "EmitWindow", data);
    return promise.then((data) => WindowEmitStatus.decode(new BinaryReader(data)));
  }

  ReadWindowTypes(request: WindowTypeRead): Promise<WindowTypes> {
    const data = WindowTypeRead.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReadWindowTypes", data);
    return promise.then((data) => WindowTypes.decode(new BinaryReader(data)));
  }
}

/**
 * ---------------------------- Core Operations ----------------------------
 *
 * OrcaProcessor defines the interface that each processing node must implement.
 * Processors are language-agnostic services that:
 * - Execute individual algorithms
 * - Handle their own internal state
 * - Report results back to the orchestrator
 * Orca will schedule processors asynchronously as per the DAG
 */
export interface OrcaProcessor {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  ExecuteDagPart(request: ExecutionRequest): Observable<ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  HealthCheck(request: HealthCheckRequest): Promise<HealthCheckResponse>;
}

export const OrcaProcessorServiceName = "OrcaProcessor";
export class OrcaProcessorClientImpl implements OrcaProcessor {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || OrcaProcessorServiceName;
    this.rpc = rpc;
    this.ExecuteDagPart = this.ExecuteDagPart.bind(this);
    this.HealthCheck = this.HealthCheck.bind(this);
  }
  ExecuteDagPart(request: ExecutionRequest): Observable<ExecutionResult> {
    const data = ExecutionRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "ExecuteDagPart", data);
    return result.pipe(map((data) => ExecutionResult.decode(new BinaryReader(data))));
  }

  HealthCheck(request: HealthCheckRequest): Promise<HealthCheckResponse> {
    const data = HealthCheckRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HealthCheck", data);
    return promise.then((data) => HealthCheckResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

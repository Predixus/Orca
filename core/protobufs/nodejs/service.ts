// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.21.12
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "";

/** ResultStatus indicates the outcome of algorithm execution */
export enum ResultStatus {
  /**
   * RESULT_STATUS_HANDLED_FAILED - Algorithm failed but the error was handled gracefully
   * The system may retry or skip depending on configuration
   */
  RESULT_STATUS_HANDLED_FAILED = 0,
  /**
   * RESULT_STATUS_UNHANDLED_FAILED - Algorithm failed with an unexpected error
   * Requires investigation and may halt dependent processing
   */
  RESULT_STATUS_UNHANDLED_FAILED = 1,
  /**
   * RESULT_STATUS_SUCEEDED - Algorithm completed successfully
   * Results are valid and can be used by dependent algorithms
   */
  RESULT_STATUS_SUCEEDED = 2,
  UNRECOGNIZED = -1,
}

export function resultStatusFromJSON(object: any): ResultStatus {
  switch (object) {
    case 0:
    case "RESULT_STATUS_HANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_HANDLED_FAILED;
    case 1:
    case "RESULT_STATUS_UNHANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_UNHANDLED_FAILED;
    case 2:
    case "RESULT_STATUS_SUCEEDED":
      return ResultStatus.RESULT_STATUS_SUCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultStatus.UNRECOGNIZED;
  }
}

export function resultStatusToJSON(object: ResultStatus): string {
  switch (object) {
    case ResultStatus.RESULT_STATUS_HANDLED_FAILED:
      return "RESULT_STATUS_HANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_UNHANDLED_FAILED:
      return "RESULT_STATUS_UNHANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_SUCEEDED:
      return "RESULT_STATUS_SUCEEDED";
    case ResultStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Window represents a time-bounded processing context that triggers algorithm execution. Windows are the primary input that start DAG processing flows. */
export interface Window {
  /**
   * Time that the window starts - nanoseconds since epoch
   * Required: Must be > 0 and < to
   */
  timeFrom?:
    | string
    | undefined;
  /**
   * Time that the window ends - nanoseconds since epoch
   * Required: Must be > from
   */
  timeTo?:
    | string
    | undefined;
  /**
   * The canonical name of the window that uniquely identifies it
   * This allows tracking of window state and results across the system
   * Required: Must be unique within the system, and refer directly to
   * window type
   */
  windowTypeName?:
    | string
    | undefined;
  /** The version of the window type, as defined by WindoType */
  windowTypeVersion?:
    | string
    | undefined;
  /** A unique identifier that defines where the window came from */
  origin?:
    | string
    | undefined;
  /**
   * Additional metadata to attach to this window
   * e.g. unique asset identifiers
   */
  metadata?: { [key: string]: any } | undefined;
}

/**
 * WindowType defines a category of window that can trigger algorithms.
 * Algorithms subscribe to window types to indicate when they should be executed.
 */
export interface WindowType {
  /**
   * Name of the window type - must be globally unique
   * Examples: "daily", "hourly", "market_close", "event_triggered"
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm. Follows basic semver and allows window
   * types to be changed over time, with traceability
   */
  version?:
    | string
    | undefined;
  /**
   * Description of the window
   * E.g. "Emitted every day, at noon"
   */
  description?: string | undefined;
}

export interface WindowEmitStatus {
  status?: WindowEmitStatus_StatusEnum | undefined;
}

/** A status enum that captures scenarios regarding a window being emmited */
export enum WindowEmitStatus_StatusEnum {
  /** NO_TRIGGERED_ALGORITHMS - When no algorithms could be found that are triggered by this window */
  NO_TRIGGERED_ALGORITHMS = 0,
  /** PROCESSING_TRIGGERED - When processing has successfully been triggered */
  PROCESSING_TRIGGERED = 1,
  /** TRIGGERING_FAILED - When triggering has failed */
  TRIGGERING_FAILED = 2,
  UNRECOGNIZED = -1,
}

export function windowEmitStatus_StatusEnumFromJSON(object: any): WindowEmitStatus_StatusEnum {
  switch (object) {
    case 0:
    case "NO_TRIGGERED_ALGORITHMS":
      return WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS;
    case 1:
    case "PROCESSING_TRIGGERED":
      return WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED;
    case 2:
    case "TRIGGERING_FAILED":
      return WindowEmitStatus_StatusEnum.TRIGGERING_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowEmitStatus_StatusEnum.UNRECOGNIZED;
  }
}

export function windowEmitStatus_StatusEnumToJSON(object: WindowEmitStatus_StatusEnum): string {
  switch (object) {
    case WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS:
      return "NO_TRIGGERED_ALGORITHMS";
    case WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED:
      return "PROCESSING_TRIGGERED";
    case WindowEmitStatus_StatusEnum.TRIGGERING_FAILED:
      return "TRIGGERING_FAILED";
    case WindowEmitStatus_StatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AlgorithmDependency defines a requirement that one algorithm has on another's results.
 * These dependencies form the edges in the processing DAG.
 */
export interface AlgorithmDependency {
  /**
   * Name of the required algorithm
   * Must reference an existing algorithm name in the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the required algorithm
   * Must follow semantic versioning (e.g., "1.0.0")
   */
  version?:
    | string
    | undefined;
  /** Name of the processor that the algorithm is associated with */
  processorName?:
    | string
    | undefined;
  /** Runtime of the processor that the algorithm is associated with */
  processorRuntime?: string | undefined;
}

/**
 * Algorithm defines a processing unit that can be executed by processors.
 * Algorithms form the nodes in the processing DAG and are triggered by specific window types.
 */
export interface Algorithm {
  /**
   * Name of the algorithm - must be globally unique
   * This identifies the algorithm across the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm - must follow semantic versioning
   * Allows for algorithm evolution while maintaining compatibility
   */
  version?:
    | string
    | undefined;
  /**
   * Type of window that triggers this algorithm
   * References a WindowType that will cause this algorithm to execute
   */
  windowType?:
    | WindowType
    | undefined;
  /**
   * Other algorithms that this algorithm depends on
   * The algorithm won't execute until all dependencies have completed
   * Dependencies must not form cycles - this is statically checked on processor registration
   */
  dependencies?: AlgorithmDependency[] | undefined;
}

/** Container for array of float values */
export interface FloatArray {
  values?: number[] | undefined;
}

/** Result of an algorithm execution */
export interface Result {
  /** Status of the result execution */
  status?:
    | ResultStatus
    | undefined;
  /** The actual result data - can be either an array of floats or a structured object */
  resultData?:
    | //
    /** for single number results */
    { $case: "singleValue"; value: number }
    | //
    /** For numeric array results */
    { $case: "floatValues"; value: FloatArray }
    | //
    /**
     * For structured data results (JSON-like)
     * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
     */
    { $case: "structValue"; value: { [key: string]: any } | undefined }
    | undefined;
  /** Timestamp when the result was produced */
  timestamp?: string | undefined;
}

/**
 * ProcessorRegistration is sent by processors when they start up to announce their capabilities
 * to the orchestrator. This establishes a long-lived connection for receiving tasks.
 */
export interface ProcessorRegistration {
  /** Unique name of the runtime */
  name?:
    | string
    | undefined;
  /**
   * Language/runtime of the processor
   * Examples: "python3.9", "go1.19", "Rust4.1"
   */
  runtime?:
    | string
    | undefined;
  /**
   * The connection string of the processor
   * e.g. grpc://localhost:5433
   */
  connectionStr?:
    | string
    | undefined;
  /**
   * Algorithms this processor can execute
   * The processor must implement all listed algorithms
   */
  supportedAlgorithms?: Algorithm[] | undefined;
}

/**
 * ProcessingTask represents a single algorithm execution request sent to a processor.
 * Tasks are streamed to processors as their dependencies are satisfied.
 */
export interface ProcessingTask {
  /**
   * Unique ID for this specific task execution
   * Used to correlate results and track execution state
   */
  taskId?:
    | string
    | undefined;
  /**
   * Algorithm to execute
   * Must be one of the algorithms the processor registered support for
   */
  algorithm?:
    | Algorithm
    | undefined;
  /**
   * Window that triggered this task
   * Provides the time context for the algorithm execution
   */
  window?:
    | Window
    | undefined;
  /**
   * Results from dependent algorithms
   * Contains all results that this algorithm declared dependencies on
   * All dependencies will be present when task is sent
   */
  dependencyResults?: Result[] | undefined;
}

/**
 * ExecutionRequest provides a complete view of a processing DAG's execution
 * status for a specific window. Used for monitoring and debugging.
 */
export interface ExecutionRequest {
  /** The exec_id */
  execId?:
    | string
    | undefined;
  /** The window that triggered the algorithm */
  window?:
    | Window
    | undefined;
  /** Results from dependant algorithms */
  algorithmResults?:
    | AlgorithmResult[]
    | undefined;
  /** The algorithms to execute */
  algorithms?: Algorithm[] | undefined;
}

export interface ExecutionResult {
  /** Exec ID */
  execId?:
    | string
    | undefined;
  /** The algorithn result */
  algorithmResult?: AlgorithmResult | undefined;
}

/** AlgorithmWindowResult Packaged algorithm and result to a window */
export interface AlgorithmResult {
  algorithm?: Algorithm | undefined;
  result?: Result | undefined;
}

export interface Status {
  received?: boolean | undefined;
  message?: string | undefined;
}

/** HealthCheckRequest is sent to processors to verify they are functioning */
export interface HealthCheckRequest {
  /**
   * Timestamp of the request in unix epoch milliseconds
   * Used to measure response latency
   */
  timestamp?: string | undefined;
}

/** HealthCheckResponse indicates the health status of a processor */
export interface HealthCheckResponse {
  /** Current health status */
  status?:
    | HealthCheckResponse_Status
    | undefined;
  /** Optional message providing more detail about the health status */
  message?:
    | string
    | undefined;
  /** System metrics about the processor */
  metrics?: ProcessorMetrics | undefined;
}

/** Overall health status of the processor */
export enum HealthCheckResponse_Status {
  /** STATUS_UNKNOWN - Unknown status - should never be used */
  STATUS_UNKNOWN = 0,
  /** STATUS_SERVING - Processor is healthy and ready to accept tasks */
  STATUS_SERVING = 1,
  /** STATUS_TRANSITIONING - Processor is starting up or shutting down */
  STATUS_TRANSITIONING = 2,
  /** STATUS_NOT_SERVING - Processor is not healthy and cannot accept tasks */
  STATUS_NOT_SERVING = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_StatusFromJSON(object: any): HealthCheckResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return HealthCheckResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_SERVING":
      return HealthCheckResponse_Status.STATUS_SERVING;
    case 2:
    case "STATUS_TRANSITIONING":
      return HealthCheckResponse_Status.STATUS_TRANSITIONING;
    case 3:
    case "STATUS_NOT_SERVING":
      return HealthCheckResponse_Status.STATUS_NOT_SERVING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_Status.UNRECOGNIZED;
  }
}

export function healthCheckResponse_StatusToJSON(object: HealthCheckResponse_Status): string {
  switch (object) {
    case HealthCheckResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case HealthCheckResponse_Status.STATUS_SERVING:
      return "STATUS_SERVING";
    case HealthCheckResponse_Status.STATUS_TRANSITIONING:
      return "STATUS_TRANSITIONING";
    case HealthCheckResponse_Status.STATUS_NOT_SERVING:
      return "STATUS_NOT_SERVING";
    case HealthCheckResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ProcessorMetrics provides runtime information about a processor */
export interface ProcessorMetrics {
  /** Number of algorithms currently being executed */
  activeTasks?:
    | number
    | undefined;
  /** Memory usage in bytes */
  memoryBytes?:
    | string
    | undefined;
  /** CPU usage percentage (0-100) */
  cpuPercent?:
    | number
    | undefined;
  /** Time since processor started in seconds */
  uptimeSeconds?: string | undefined;
}

/** ---------------------------- Data Messages ---------------------------- */
export interface WindowTypeRead {
}

export interface WindowTypes {
  windows?: WindowType[] | undefined;
}

export interface AlgorithmsRead {
}

export interface Algorithms {
  algorithm?: Algorithm[] | undefined;
}

export interface ProcessorsRead {
}

export interface Processors {
  processor?: Processors_Processor[] | undefined;
}

export interface Processors_Processor {
  name?: string | undefined;
  runtime?: string | undefined;
}

export interface ResultsStatsRead {
}

export interface ResultsStats {
  Count?: string | undefined;
}

function createBaseWindow(): Window {
  return { timeFrom: "0", timeTo: "0", windowTypeName: "", windowTypeVersion: "", origin: "", metadata: undefined };
}

export const Window: MessageFns<Window> = {
  encode(message: Window, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined && message.timeFrom !== "0") {
      writer.uint32(8).uint64(message.timeFrom);
    }
    if (message.timeTo !== undefined && message.timeTo !== "0") {
      writer.uint32(16).uint64(message.timeTo);
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      writer.uint32(26).string(message.windowTypeName);
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      writer.uint32(34).string(message.windowTypeVersion);
    }
    if (message.origin !== undefined && message.origin !== "") {
      writer.uint32(42).string(message.origin);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Window {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeFrom = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timeTo = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowTypeVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Window {
    return {
      timeFrom: isSet(object.timeFrom) ? globalThis.String(object.timeFrom) : "0",
      timeTo: isSet(object.timeTo) ? globalThis.String(object.timeTo) : "0",
      windowTypeName: isSet(object.windowTypeName) ? globalThis.String(object.windowTypeName) : "",
      windowTypeVersion: isSet(object.windowTypeVersion) ? globalThis.String(object.windowTypeVersion) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Window): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined && message.timeFrom !== "0") {
      obj.timeFrom = message.timeFrom;
    }
    if (message.timeTo !== undefined && message.timeTo !== "0") {
      obj.timeTo = message.timeTo;
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      obj.windowTypeName = message.windowTypeName;
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      obj.windowTypeVersion = message.windowTypeVersion;
    }
    if (message.origin !== undefined && message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Window>, I>>(base?: I): Window {
    return Window.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Window>, I>>(object: I): Window {
    const message = createBaseWindow();
    message.timeFrom = object.timeFrom ?? "0";
    message.timeTo = object.timeTo ?? "0";
    message.windowTypeName = object.windowTypeName ?? "";
    message.windowTypeVersion = object.windowTypeVersion ?? "";
    message.origin = object.origin ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseWindowType(): WindowType {
  return { name: "", version: "", description: "" };
}

export const WindowType: MessageFns<WindowType> = {
  encode(message: WindowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: WindowType): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowType>, I>>(base?: I): WindowType {
    return WindowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowType>, I>>(object: I): WindowType {
    const message = createBaseWindowType();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWindowEmitStatus(): WindowEmitStatus {
  return { status: 0 };
}

export const WindowEmitStatus: MessageFns<WindowEmitStatus> = {
  encode(message: WindowEmitStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowEmitStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowEmitStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowEmitStatus {
    return { status: isSet(object.status) ? windowEmitStatus_StatusEnumFromJSON(object.status) : 0 };
  },

  toJSON(message: WindowEmitStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = windowEmitStatus_StatusEnumToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(base?: I): WindowEmitStatus {
    return WindowEmitStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(object: I): WindowEmitStatus {
    const message = createBaseWindowEmitStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseAlgorithmDependency(): AlgorithmDependency {
  return { name: "", version: "", processorName: "", processorRuntime: "" };
}

export const AlgorithmDependency: MessageFns<AlgorithmDependency> = {
  encode(message: AlgorithmDependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      writer.uint32(26).string(message.processorName);
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      writer.uint32(34).string(message.processorRuntime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmDependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processorRuntime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmDependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      processorName: isSet(object.processorName) ? globalThis.String(object.processorName) : "",
      processorRuntime: isSet(object.processorRuntime) ? globalThis.String(object.processorRuntime) : "",
    };
  },

  toJSON(message: AlgorithmDependency): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      obj.processorName = message.processorName;
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      obj.processorRuntime = message.processorRuntime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(base?: I): AlgorithmDependency {
    return AlgorithmDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(object: I): AlgorithmDependency {
    const message = createBaseAlgorithmDependency();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.processorName = object.processorName ?? "";
    message.processorRuntime = object.processorRuntime ?? "";
    return message;
  },
};

function createBaseAlgorithm(): Algorithm {
  return { name: "", version: "", windowType: undefined, dependencies: [] };
}

export const Algorithm: MessageFns<Algorithm> = {
  encode(message: Algorithm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.windowType !== undefined) {
      WindowType.encode(message.windowType, writer.uint32(26).fork()).join();
    }
    if (message.dependencies !== undefined && message.dependencies.length !== 0) {
      for (const v of message.dependencies) {
        AlgorithmDependency.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowType = WindowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = AlgorithmDependency.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencies!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithm {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      windowType: isSet(object.windowType) ? WindowType.fromJSON(object.windowType) : undefined,
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => AlgorithmDependency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Algorithm): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.windowType !== undefined) {
      obj.windowType = WindowType.toJSON(message.windowType);
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => AlgorithmDependency.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithm>, I>>(base?: I): Algorithm {
    return Algorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithm>, I>>(object: I): Algorithm {
    const message = createBaseAlgorithm();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.windowType = (object.windowType !== undefined && object.windowType !== null)
      ? WindowType.fromPartial(object.windowType)
      : undefined;
    message.dependencies = object.dependencies?.map((e) => AlgorithmDependency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatArray(): FloatArray {
  return { values: [] };
}

export const FloatArray: MessageFns<FloatArray> = {
  encode(message: FloatArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values !== undefined && message.values.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.values) {
        writer.float(v);
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values!.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values!.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatArray>, I>>(base?: I): FloatArray {
    return FloatArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatArray>, I>>(object: I): FloatArray {
    const message = createBaseFloatArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseResult(): Result {
  return { status: 0, resultData: undefined, timestamp: "0" };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    switch (message.resultData?.$case) {
      case "singleValue":
        writer.uint32(21).float(message.resultData.value);
        break;
      case "floatValues":
        FloatArray.encode(message.resultData.value, writer.uint32(26).fork()).join();
        break;
      case "structValue":
        Struct.encode(Struct.wrap(message.resultData.value), writer.uint32(34).fork()).join();
        break;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.resultData = { $case: "singleValue", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultData = { $case: "floatValues", value: FloatArray.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resultData = { $case: "structValue", value: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      status: isSet(object.status) ? resultStatusFromJSON(object.status) : 0,
      resultData: isSet(object.singleValue)
        ? { $case: "singleValue", value: globalThis.Number(object.singleValue) }
        : isSet(object.floatValues)
        ? { $case: "floatValues", value: FloatArray.fromJSON(object.floatValues) }
        : isSet(object.structValue)
        ? { $case: "structValue", value: object.structValue }
        : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = resultStatusToJSON(message.status);
    }
    if (message.resultData?.$case === "singleValue") {
      obj.singleValue = message.resultData.value;
    } else if (message.resultData?.$case === "floatValues") {
      obj.floatValues = FloatArray.toJSON(message.resultData.value);
    } else if (message.resultData?.$case === "structValue") {
      obj.structValue = message.resultData.value;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.status = object.status ?? 0;
    switch (object.resultData?.$case) {
      case "singleValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "singleValue", value: object.resultData.value };
        }
        break;
      }
      case "floatValues": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "floatValues", value: FloatArray.fromPartial(object.resultData.value) };
        }
        break;
      }
      case "structValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "structValue", value: object.resultData.value };
        }
        break;
      }
    }
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseProcessorRegistration(): ProcessorRegistration {
  return { name: "", runtime: "", connectionStr: "", supportedAlgorithms: [] };
}

export const ProcessorRegistration: MessageFns<ProcessorRegistration> = {
  encode(message: ProcessorRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      writer.uint32(26).string(message.connectionStr);
    }
    if (message.supportedAlgorithms !== undefined && message.supportedAlgorithms.length !== 0) {
      for (const v of message.supportedAlgorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectionStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.supportedAlgorithms!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorRegistration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      connectionStr: isSet(object.connectionStr) ? globalThis.String(object.connectionStr) : "",
      supportedAlgorithms: globalThis.Array.isArray(object?.supportedAlgorithms)
        ? object.supportedAlgorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorRegistration): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      obj.connectionStr = message.connectionStr;
    }
    if (message.supportedAlgorithms?.length) {
      obj.supportedAlgorithms = message.supportedAlgorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(base?: I): ProcessorRegistration {
    return ProcessorRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(object: I): ProcessorRegistration {
    const message = createBaseProcessorRegistration();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    message.connectionStr = object.connectionStr ?? "";
    message.supportedAlgorithms = object.supportedAlgorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessingTask(): ProcessingTask {
  return { taskId: "", algorithm: undefined, window: undefined, dependencyResults: [] };
}

export const ProcessingTask: MessageFns<ProcessingTask> = {
  encode(message: ProcessingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== undefined && message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(26).fork()).join();
    }
    if (message.dependencyResults !== undefined && message.dependencyResults.length !== 0) {
      for (const v of message.dependencyResults) {
        Result.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Result.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencyResults!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      dependencyResults: globalThis.Array.isArray(object?.dependencyResults)
        ? object.dependencyResults.map((e: any) => Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessingTask): unknown {
    const obj: any = {};
    if (message.taskId !== undefined && message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.dependencyResults?.length) {
      obj.dependencyResults = message.dependencyResults.map((e) => Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingTask>, I>>(base?: I): ProcessingTask {
    return ProcessingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingTask>, I>>(object: I): ProcessingTask {
    const message = createBaseProcessingTask();
    message.taskId = object.taskId ?? "";
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.dependencyResults = object.dependencyResults?.map((e) => Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionRequest(): ExecutionRequest {
  return { execId: "", window: undefined, algorithmResults: [], algorithms: [] };
}

export const ExecutionRequest: MessageFns<ExecutionRequest> = {
  encode(message: ExecutionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(18).fork()).join();
    }
    if (message.algorithmResults !== undefined && message.algorithmResults.length !== 0) {
      for (const v of message.algorithmResults) {
        AlgorithmResult.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.algorithms !== undefined && message.algorithms.length !== 0) {
      for (const v of message.algorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = AlgorithmResult.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithmResults!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithms!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionRequest {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      algorithmResults: globalThis.Array.isArray(object?.algorithmResults)
        ? object.algorithmResults.map((e: any) => AlgorithmResult.fromJSON(e))
        : [],
      algorithms: globalThis.Array.isArray(object?.algorithms)
        ? object.algorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecutionRequest): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.algorithmResults?.length) {
      obj.algorithmResults = message.algorithmResults.map((e) => AlgorithmResult.toJSON(e));
    }
    if (message.algorithms?.length) {
      obj.algorithms = message.algorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionRequest>, I>>(base?: I): ExecutionRequest {
    return ExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionRequest>, I>>(object: I): ExecutionRequest {
    const message = createBaseExecutionRequest();
    message.execId = object.execId ?? "";
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.algorithmResults = object.algorithmResults?.map((e) => AlgorithmResult.fromPartial(e)) || [];
    message.algorithms = object.algorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { execId: "", algorithmResult: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.algorithmResult !== undefined) {
      AlgorithmResult.encode(message.algorithmResult, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithmResult = AlgorithmResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      algorithmResult: isSet(object.algorithmResult) ? AlgorithmResult.fromJSON(object.algorithmResult) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.algorithmResult !== undefined) {
      obj.algorithmResult = AlgorithmResult.toJSON(message.algorithmResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.execId = object.execId ?? "";
    message.algorithmResult = (object.algorithmResult !== undefined && object.algorithmResult !== null)
      ? AlgorithmResult.fromPartial(object.algorithmResult)
      : undefined;
    return message;
  },
};

function createBaseAlgorithmResult(): AlgorithmResult {
  return { algorithm: undefined, result: undefined };
}

export const AlgorithmResult: MessageFns<AlgorithmResult> = {
  encode(message: AlgorithmResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmResult {
    return {
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: AlgorithmResult): unknown {
    const obj: any = {};
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmResult>, I>>(base?: I): AlgorithmResult {
    return AlgorithmResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmResult>, I>>(object: I): AlgorithmResult {
    const message = createBaseAlgorithmResult();
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseStatus(): Status {
  return { received: false, message: "" };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.received !== undefined && message.received !== false) {
      writer.uint32(8).bool(message.received);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.received = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      received: isSet(object.received) ? globalThis.Boolean(object.received) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.received !== undefined && message.received !== false) {
      obj.received = message.received;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.received = object.received ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { timestamp: "0" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, message: "", metrics: undefined };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metrics !== undefined) {
      ProcessorMetrics.encode(message.metrics, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics = ProcessorMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthCheckResponse_StatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: isSet(object.metrics) ? ProcessorMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = healthCheckResponse_StatusToJSON(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics !== undefined) {
      obj.metrics = ProcessorMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ProcessorMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseProcessorMetrics(): ProcessorMetrics {
  return { activeTasks: 0, memoryBytes: "0", cpuPercent: 0, uptimeSeconds: "0" };
}

export const ProcessorMetrics: MessageFns<ProcessorMetrics> = {
  encode(message: ProcessorMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      writer.uint32(8).int32(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      writer.uint32(16).int64(message.memoryBytes);
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      writer.uint32(29).float(message.cpuPercent);
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      writer.uint32(32).int64(message.uptimeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeTasks = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryBytes = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.cpuPercent = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uptimeSeconds = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorMetrics {
    return {
      activeTasks: isSet(object.activeTasks) ? globalThis.Number(object.activeTasks) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      cpuPercent: isSet(object.cpuPercent) ? globalThis.Number(object.cpuPercent) : 0,
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
    };
  },

  toJSON(message: ProcessorMetrics): unknown {
    const obj: any = {};
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      obj.activeTasks = Math.round(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      obj.cpuPercent = message.cpuPercent;
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(base?: I): ProcessorMetrics {
    return ProcessorMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(object: I): ProcessorMetrics {
    const message = createBaseProcessorMetrics();
    message.activeTasks = object.activeTasks ?? 0;
    message.memoryBytes = object.memoryBytes ?? "0";
    message.cpuPercent = object.cpuPercent ?? 0;
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    return message;
  },
};

function createBaseWindowTypeRead(): WindowTypeRead {
  return {};
}

export const WindowTypeRead: MessageFns<WindowTypeRead> = {
  encode(_: WindowTypeRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypeRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypeRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WindowTypeRead {
    return {};
  },

  toJSON(_: WindowTypeRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypeRead>, I>>(base?: I): WindowTypeRead {
    return WindowTypeRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypeRead>, I>>(_: I): WindowTypeRead {
    const message = createBaseWindowTypeRead();
    return message;
  },
};

function createBaseWindowTypes(): WindowTypes {
  return { windows: [] };
}

export const WindowTypes: MessageFns<WindowTypes> = {
  encode(message: WindowTypes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.windows !== undefined && message.windows.length !== 0) {
      for (const v of message.windows) {
        WindowType.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = WindowType.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.windows!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowTypes {
    return {
      windows: globalThis.Array.isArray(object?.windows) ? object.windows.map((e: any) => WindowType.fromJSON(e)) : [],
    };
  },

  toJSON(message: WindowTypes): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => WindowType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypes>, I>>(base?: I): WindowTypes {
    return WindowTypes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypes>, I>>(object: I): WindowTypes {
    const message = createBaseWindowTypes();
    message.windows = object.windows?.map((e) => WindowType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlgorithmsRead(): AlgorithmsRead {
  return {};
}

export const AlgorithmsRead: MessageFns<AlgorithmsRead> = {
  encode(_: AlgorithmsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AlgorithmsRead {
    return {};
  },

  toJSON(_: AlgorithmsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmsRead>, I>>(base?: I): AlgorithmsRead {
    return AlgorithmsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmsRead>, I>>(_: I): AlgorithmsRead {
    const message = createBaseAlgorithmsRead();
    return message;
  },
};

function createBaseAlgorithms(): Algorithms {
  return { algorithm: [] };
}

export const Algorithms: MessageFns<Algorithms> = {
  encode(message: Algorithms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined && message.algorithm.length !== 0) {
      for (const v of message.algorithm) {
        Algorithm.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithm!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithms {
    return {
      algorithm: globalThis.Array.isArray(object?.algorithm)
        ? object.algorithm.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Algorithms): unknown {
    const obj: any = {};
    if (message.algorithm?.length) {
      obj.algorithm = message.algorithm.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithms>, I>>(base?: I): Algorithms {
    return Algorithms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithms>, I>>(object: I): Algorithms {
    const message = createBaseAlgorithms();
    message.algorithm = object.algorithm?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorsRead(): ProcessorsRead {
  return {};
}

export const ProcessorsRead: MessageFns<ProcessorsRead> = {
  encode(_: ProcessorsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ProcessorsRead {
    return {};
  },

  toJSON(_: ProcessorsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorsRead>, I>>(base?: I): ProcessorsRead {
    return ProcessorsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorsRead>, I>>(_: I): ProcessorsRead {
    const message = createBaseProcessorsRead();
    return message;
  },
};

function createBaseProcessors(): Processors {
  return { processor: [] };
}

export const Processors: MessageFns<Processors> = {
  encode(message: Processors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined && message.processor.length !== 0) {
      for (const v of message.processor) {
        Processors_Processor.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Processors_Processor.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.processor!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processors {
    return {
      processor: globalThis.Array.isArray(object?.processor)
        ? object.processor.map((e: any) => Processors_Processor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Processors): unknown {
    const obj: any = {};
    if (message.processor?.length) {
      obj.processor = message.processor.map((e) => Processors_Processor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processors>, I>>(base?: I): Processors {
    return Processors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processors>, I>>(object: I): Processors {
    const message = createBaseProcessors();
    message.processor = object.processor?.map((e) => Processors_Processor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessors_Processor(): Processors_Processor {
  return { name: "", runtime: "" };
}

export const Processors_Processor: MessageFns<Processors_Processor> = {
  encode(message: Processors_Processor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processors_Processor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessors_Processor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processors_Processor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
    };
  },

  toJSON(message: Processors_Processor): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processors_Processor>, I>>(base?: I): Processors_Processor {
    return Processors_Processor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processors_Processor>, I>>(object: I): Processors_Processor {
    const message = createBaseProcessors_Processor();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    return message;
  },
};

function createBaseResultsStatsRead(): ResultsStatsRead {
  return {};
}

export const ResultsStatsRead: MessageFns<ResultsStatsRead> = {
  encode(_: ResultsStatsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsStatsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsStatsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResultsStatsRead {
    return {};
  },

  toJSON(_: ResultsStatsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsStatsRead>, I>>(base?: I): ResultsStatsRead {
    return ResultsStatsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsStatsRead>, I>>(_: I): ResultsStatsRead {
    const message = createBaseResultsStatsRead();
    return message;
  },
};

function createBaseResultsStats(): ResultsStats {
  return { Count: "0" };
}

export const ResultsStats: MessageFns<ResultsStats> = {
  encode(message: ResultsStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Count !== undefined && message.Count !== "0") {
      writer.uint32(8).int64(message.Count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Count = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsStats {
    return { Count: isSet(object.Count) ? globalThis.String(object.Count) : "0" };
  },

  toJSON(message: ResultsStats): unknown {
    const obj: any = {};
    if (message.Count !== undefined && message.Count !== "0") {
      obj.Count = message.Count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsStats>, I>>(base?: I): ResultsStats {
    return ResultsStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsStats>, I>>(object: I): ResultsStats {
    const message = createBaseResultsStats();
    message.Count = object.Count ?? "0";
    return message;
  },
};

/**
 * OrcaCore is the central orchestration service that:
 * - Manages the lifecycle of processing windows
 * - Coordinates algorithm execution across distributed processors
 * - Tracks DAG dependencies and execution state
 * - Routes results between dependent algorithms
 */
export type OrcaCoreService = typeof OrcaCoreService;
export const OrcaCoreService = {
  /** Register a processor node and its supported algorithms */
  registerProcessor: {
    path: "/OrcaCore/RegisterProcessor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessorRegistration): Buffer =>
      Buffer.from(ProcessorRegistration.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessorRegistration => ProcessorRegistration.decode(value),
    responseSerialize: (value: Status): Buffer => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer): Status => Status.decode(value),
  },
  /** Submit a window for processing */
  emitWindow: {
    path: "/OrcaCore/EmitWindow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Window): Buffer => Buffer.from(Window.encode(value).finish()),
    requestDeserialize: (value: Buffer): Window => Window.decode(value),
    responseSerialize: (value: WindowEmitStatus): Buffer => Buffer.from(WindowEmitStatus.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowEmitStatus => WindowEmitStatus.decode(value),
  },
  /** ------------------- Data operations ------------------- */
  readWindowTypes: {
    path: "/OrcaCore/ReadWindowTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WindowTypeRead): Buffer => Buffer.from(WindowTypeRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): WindowTypeRead => WindowTypeRead.decode(value),
    responseSerialize: (value: WindowTypes): Buffer => Buffer.from(WindowTypes.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowTypes => WindowTypes.decode(value),
  },
  readAlgorithms: {
    path: "/OrcaCore/ReadAlgorithms",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AlgorithmsRead): Buffer => Buffer.from(AlgorithmsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): AlgorithmsRead => AlgorithmsRead.decode(value),
    responseSerialize: (value: Algorithms): Buffer => Buffer.from(Algorithms.encode(value).finish()),
    responseDeserialize: (value: Buffer): Algorithms => Algorithms.decode(value),
  },
  readProcessors: {
    path: "/OrcaCore/ReadProcessors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessorsRead): Buffer => Buffer.from(ProcessorsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessorsRead => ProcessorsRead.decode(value),
    responseSerialize: (value: Processors): Buffer => Buffer.from(Processors.encode(value).finish()),
    responseDeserialize: (value: Buffer): Processors => Processors.decode(value),
  },
  readResultsStats: {
    path: "/OrcaCore/ReadResultsStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResultsStatsRead): Buffer => Buffer.from(ResultsStatsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResultsStatsRead => ResultsStatsRead.decode(value),
    responseSerialize: (value: ResultsStats): Buffer => Buffer.from(ResultsStats.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResultsStats => ResultsStats.decode(value),
  },
} as const;

export interface OrcaCoreServer extends UntypedServiceImplementation {
  /** Register a processor node and its supported algorithms */
  registerProcessor: handleUnaryCall<ProcessorRegistration, Status>;
  /** Submit a window for processing */
  emitWindow: handleUnaryCall<Window, WindowEmitStatus>;
  /** ------------------- Data operations ------------------- */
  readWindowTypes: handleUnaryCall<WindowTypeRead, WindowTypes>;
  readAlgorithms: handleUnaryCall<AlgorithmsRead, Algorithms>;
  readProcessors: handleUnaryCall<ProcessorsRead, Processors>;
  readResultsStats: handleUnaryCall<ResultsStatsRead, ResultsStats>;
}

export interface OrcaCoreClient extends Client {
  /** Register a processor node and its supported algorithms */
  registerProcessor(
    request: ProcessorRegistration,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  /** Submit a window for processing */
  emitWindow(
    request: Window,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  /** ------------------- Data operations ------------------- */
  readWindowTypes(
    request: WindowTypeRead,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readWindowTypes(
    request: WindowTypeRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readWindowTypes(
    request: WindowTypeRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
}

export const OrcaCoreClient = makeGenericClientConstructor(OrcaCoreService, "OrcaCore") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaCoreClient;
  service: typeof OrcaCoreService;
  serviceName: string;
};

/**
 * OrcaProcessor defines the interface that each processing node must implement.
 * Processors are language-agnostic services that:
 * - Execute individual algorithms
 * - Handle their own internal state
 * - Report results back to the orchestrator
 * Orca will schedule processors asynchronously as per the DAG
 */
export type OrcaProcessorService = typeof OrcaProcessorService;
export const OrcaProcessorService = {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: {
    path: "/OrcaProcessor/ExecuteDagPart",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExecutionRequest): Buffer => Buffer.from(ExecutionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecutionRequest => ExecutionRequest.decode(value),
    responseSerialize: (value: ExecutionResult): Buffer => Buffer.from(ExecutionResult.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecutionResult => ExecutionResult.decode(value),
  },
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: {
    path: "/OrcaProcessor/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface OrcaProcessorServer extends UntypedServiceImplementation {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: handleServerStreamingCall<ExecutionRequest, ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface OrcaProcessorClient extends Client {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart(request: ExecutionRequest, options?: Partial<CallOptions>): ClientReadableStream<ExecutionResult>;
  executeDagPart(
    request: ExecutionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const OrcaProcessorClient = makeGenericClientConstructor(OrcaProcessorService, "OrcaProcessor") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaProcessorClient;
  service: typeof OrcaProcessorService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

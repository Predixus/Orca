syntax="proto3";

option go_package = "github.com/predixus/orca/protobufs/go";

// Services for the core orchestrator that processors connect to
service OrcaCore {
  // Register a processor node and its supported algorithms
  rpc RegisterProcessor(ProcessorRegistration) returns (stream ProcessingTask);

  // Submit a window for processing
  rpc EmitWindow(Window) returns (Status);

  // Register a new window type
  rpc RegisterWindowType(WindowType) returns (Status);

  // Register a new algorithm type
  rpc RegisterAlgorithm(Algorithm) returns (Status);

  // Submit results from algorithm execution
  rpc SubmitResult(Result) returns (Status);

  // Get the current state of a DAG execution
  rpc GetDagState(DagStateRequest) returns (DagState);
}

// Services that each processor node must implement
service OrcaProcessor {
  // Execute an algorithm with given inputs
  rpc ExecuteAlgorithm(ExecutionRequest) returns (ExecutionResult);

  // Check health/status of processor
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message Window {
  // Time that the window starts - nanoseconds since epoch
  uint64 from = 1;

  // Time that the window ends - nanoseconds since epoch
  uint64 to = 2;
  
  // The canonical name of the window. This uniquely identifiers the window
  string name = 3;
}

message WindowType {
  // Name of the window - globally unique
  string name = 1;
}

message AlgorithmDependency {

  // Name of the algorithm that this depends on
  string name = 1;

  // Version of the algorithm that this depends on
  string version = 2;
}

message Algorithm {
  // Name of the algorithm - globally unique
  string name = 1;

  // Version of the algorithm - must follow semver
  string version = 2;

  // Type of window that triggers this algorithm
  string window_type_name = 3;

  // Other algorithms that this algorithm depends on
  repeated AlgorithmDependency dependencies = 4;
}

enum ResultStatus {
  RESULT_STATUS_HANDLED_FAILED = 0;
  RESULT_STATUS_UNHANDLED_FAILED = 1;
  RESULT_STATUS_SUCEEDED = 2;
}

// Result of an algorithm
message Result {
  // Name of the algorithm that produced the result
  string algorithm_name = 1;

  // Version of the algorithm that produced the result
  string version = 2;
  
  // Status of the result
  ResultStatus status = 3;
}

message ProcessorRegistration {
  // Unique ID for this processor instance
  string processor_id = 1;
  // Language/runtime of the processor
  string runtime = 2;
  // Algorithms this processor can execute
  repeated Algorithm supported_algorithms = 3;
}

message ProcessingTask {
  // ID of the task
  string task_id = 1;
  // Algorithm to execute
  Algorithm algorithm = 2;
  // Window that triggered this task
  Window window = 3;
  // Results from dependent algorithms
  repeated Result dependency_results = 4;
}

message ExecutionRequest {
  // Task ID from ProcessingTask
  string task_id = 1;
  // Algorithm to execute
  Algorithm algorithm = 2;
  // Input data/parameters
  map<string, bytes> inputs = 3;
}

message ExecutionResult {
  // Task ID
  string task_id = 1;
  // Execution status
  ResultStatus status = 2;
  // Output data
  map<string, bytes> outputs = 3;
}

message DagStateRequest {
  // Window ID to query
  string window_id = 1;
}

message DagState {
  // Window being processed
  Window window = 1;
  // Status of each algorithm
  repeated AlgorithmState algorithm_states = 2;
}

message AlgorithmState {
  // Algorithm info
  Algorithm algorithm = 1;
  // Current status
  string status = 2;
  // Result if completed
  Result result = 3;
}

message Status {
  bool received = 1;
  string message = 2;
}
